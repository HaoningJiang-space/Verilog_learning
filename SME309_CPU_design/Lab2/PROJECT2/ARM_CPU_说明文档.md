# ARM CPU 设计说明文档

## 项目概述

本项目实现了一个单周期ARM处理器,支持基本的数据处理指令、加载/存储指令和分支指令。该设计针对Nexys4 FPGA开发板进行了优化,包含完整的I/O接口(LED、七段数码管、DIP开关、按钮)。

---

## 模块层次结构

```
TOP_Nexys4 (顶层模块 - FPGA接口)
└── Wrapper (CPU与存储器封装)
    └── ARM (ARM CPU核心)
        ├── ProgramCounter (程序计数器)
        ├── ControlUnit (控制单元)
        │   ├── Decoder (指令译码器)
        │   └── CondLogic (条件执行逻辑)
        ├── RegisterFile (寄存器堆)
        ├── ALU (算术逻辑单元)
        ├── Shifter (桶形移位器)
        └── Extend (立即数扩展单元)
```

---

## 各模块功能说明

### 1. TOP_Nexys4 (顶层模块)

**功能**: FPGA顶层模块,负责I/O接口和时钟管理

**主要特性**:
- 时钟分频: 将100MHz FPGA时钟分频到约3Hz CPU时钟(可配置)
- 七段数码管驱动: 1kHz刷新率的8位数码管多路复用控制
- 按钮接口: RESET(复位)、PAUSE(暂停)
- LED显示: 显示程序计数器PC的值
- DIP开关: 用于选择要查看的存储器地址

**接口信号**:
- 输入:
  - `CLK_undiv`: 100MHz时钟输入
  - `RESET`: 复位按钮(高电平有效)
  - `PAUSE`: 暂停按钮
  - `DIP[6:0]`: 7位DIP开关,用于选择存储器地址
- 输出:
  - `LED[15:0]`: LED显示,显示PC值
  - `SevenSegAn[7:0]`: 七段数码管阳极(低电平有效)
  - `SevenSegCat[6:0]`: 七段数码管阴极

**关键参数**:
- `CLK_DIV_BITS = 25`: 时钟分频位数,25位约为3Hz

---

### 2. Wrapper (存储器封装模块)

**功能**: 集成ARM CPU核心与存储器系统

**主要特性**:
- 指令存储器: 128个32位字(地址范围: 0x00000000 - 0x000001FC)
- 常量数据存储器: 128个32位字(地址范围: 0x00000200 - 0x000003FC)
- 变量数据存储器: 128个32位字(地址范围: 0x00000800 - 0x000009FC)
- 存储器地址译码
- I/O接口管理

**存储器映射**:
```
0x00000000 - 0x000001FC: 指令存储器 (只读)
0x00000200 - 0x000003FC: 常量数据存储器 (只读)
0x00000800 - 0x000009FC: 变量数据存储器 (可读写)
```

**关键功能**:
1. **指令读取**: 根据PC值从指令存储器读取指令
2. **数据读取**: 根据ALU结果地址从相应存储器读取数据
3. **数据写入**: 当MemWrite有效时,写入变量数据存储器
4. **显示输出**: 将DIP开关选择的存储器内容输出到七段数码管

---

### 3. ARM (ARM CPU核心)

**功能**: ARM处理器数据通路核心

**主要特性**:
- 单周期执行
- 支持条件执行
- 32位数据通路
- 集成所有功能单元

**数据通路**:
1. **取指**: PC → 指令存储器 → Instr
2. **译码**: Instr → ControlUnit → 控制信号
3. **执行**:
   - 寄存器读取 → Shifter → ALU → ALUResult
   - 或立即数扩展 → ALU → ALUResult
4. **访存**: ALUResult (作为地址) → 数据存储器 → ReadData
5. **写回**: ALUResult 或 ReadData → 寄存器堆

**信号流**:
```
指令字段提取:
Instr[31:28] → Cond (条件码)
Instr[27:26] → Op (操作类型)
Instr[25]    → I (立即数标志)
Instr[24:21] → Cmd (命令字段)
Instr[20]    → S (设置标志位)
Instr[19:16] → Rn (第一源寄存器)
Instr[15:12] → Rd (目标寄存器)
Instr[11:7]  → Shamt5 (移位量)
Instr[6:5]   → Sh (移位类型)
Instr[3:0]   → Rm (第二源寄存器)
Instr[23:0]  → InstrImm (立即数字段)
```

---

### 4. ProgramCounter (程序计数器)

**功能**: 管理程序执行流程

**主要特性**:
- 复位时PC = 0
- 正常情况下PC = PC + 4(顺序执行)
- 分支时PC = ALUResult(跳转执行)

**控制逻辑**:
- `PCSrc = 0`: 顺序执行,PC ← PC + 4
- `PCSrc = 1`: 分支跳转,PC ← Result

**输出**:
- `PC`: 当前程序计数器值
- `PC_Plus_4`: PC + 4,用于顺序执行和计算PC+8

---

### 5. ControlUnit (控制单元)

**功能**: 生成所有数据通路控制信号

**主要特性**:
- 指令译码
- 条件执行控制
- 标志位管理

**组成**:
- **Decoder**: 指令译码器,生成无条件控制信号
- **CondLogic**: 条件逻辑,根据条件码和标志位生成最终控制信号

**控制信号**:
- `MemtoReg`: 选择写回寄存器的数据(0=ALU结果, 1=存储器数据)
- `MemWrite`: 存储器写使能
- `ALUSrc`: ALU第二操作数来源(0=移位后的寄存器, 1=立即数)
- `ImmSrc[1:0]`: 立即数扩展类型
- `RegWrite`: 寄存器写使能
- `RegSrc[1:0]`: 寄存器地址选择
- `ALUControl[1:0]`: ALU操作类型
- `PCSrc`: PC来源选择

---

### 6. Decoder (指令译码器)

**功能**: 将32位指令译码为控制信号

**支持的指令类型**:

#### 数据处理指令 (Op = 00)
- **寄存器型** (Instr[25]=0):
  - ADD, SUB, AND, ORR, CMP, CMN
  - 支持移位操作
- **立即数型** (Instr[25]=1):
  - 与寄存器型相同,但第二操作数为立即数

**ALU操作编码**:
- `ALUControl = 00`: ADD
- `ALUControl = 01`: SUB
- `ALUControl = 10`: AND
- `ALUControl = 11`: OR

**标志位控制**:
- `FlagW[1]`: 控制N、Z标志位更新
- `FlagW[0]`: 控制C、V标志位更新
- `NoWrite`: CMP/CMN指令不写回寄存器

#### 存储器访问指令 (Op = 01)
- **LDR** (加载, Instr[20]=1):
  - 从存储器读取数据到寄存器
  - 支持正负偏移(U位 Instr[23])
- **STR** (存储, Instr[20]=0):
  - 将寄存器数据写入存储器
  - 支持正负偏移

**地址计算**:
- U=1 (Instr[23]=1): 地址 = Rn + offset
- U=0 (Instr[23]=0): 地址 = Rn - offset

#### 分支指令 (Op = 10)
- **B** (无条件分支):
  - PC = PC + 8 + SignExt(Imm24 << 2)
- **条件分支**:
  - 根据条件码和标志位决定是否跳转

**PCS逻辑**:
- 分支指令: `PCS = 1`
- 写入R15: `PCS = 1` (Rd = 15 且 RegW = 1)
- 其他: `PCS = 0`

---

### 7. CondLogic (条件执行逻辑)

**功能**: 实现ARM的条件执行特性

**标志位**:
- **N** (Negative): 结果为负
- **Z** (Zero): 结果为零
- **C** (Carry): 进位/借位
- **V** (Overflow): 有符号溢出

**条件码** (Cond[3:0]):
| 编码 | 助记符 | 含义 | 条件 |
|-----|--------|------|------|
| 0000 | EQ | 相等 | Z = 1 |
| 0001 | NE | 不相等 | Z = 0 |
| 0010 | CS/HS | 进位/无符号大于等于 | C = 1 |
| 0011 | CC/LO | 无进位/无符号小于 | C = 0 |
| 0100 | MI | 负数 | N = 1 |
| 0101 | PL | 正数或零 | N = 0 |
| 0110 | VS | 溢出 | V = 1 |
| 0111 | VC | 无溢出 | V = 0 |
| 1000 | HI | 无符号大于 | C=1 且 Z=0 |
| 1001 | LS | 无符号小于等于 | C=0 或 Z=1 |
| 1010 | GE | 有符号大于等于 | N = V |
| 1011 | LT | 有符号小于 | N ≠ V |
| 1100 | GT | 有符号大于 | Z=0 且 N=V |
| 1101 | LE | 有符号小于等于 | Z=1 或 N≠V |
| 1110 | AL | 总是执行 | 1 |

**条件执行控制**:
- 仅当条件满足时,才执行以下操作:
  - 写入寄存器 (RegWrite)
  - 写入存储器 (MemWrite)
  - 更新PC (PCSrc)
  - 更新标志位

---

### 8. RegisterFile (寄存器堆)

**功能**: 存储通用寄存器

**主要特性**:
- 15个32位通用寄存器 (R0-R14)
- R15即PC,由ProgramCounter模块单独处理
- 双端口读取
- 单端口写入

**读取端口**:
- `A1` → `RD1`: 第一读端口
- `A2` → `RD2`: 第二读端口
- 当地址为15时,返回R15(PC+8)的值

**写入端口**:
- `A3`: 写地址
- `WD3`: 写数据
- `WE3`: 写使能(高电平有效)
- 在时钟上升沿写入

**特殊处理**:
- R15读取时返回PC+8(而非当前PC),这是ARM架构的特性
- R15不存储在RegBank中

---

### 9. ALU (算术逻辑单元)

**功能**: 执行算术和逻辑运算

**支持的操作**:
- `ALUControl = 00`: ADD (加法)
- `ALUControl = 01`: SUB (减法)
- `ALUControl = 10`: AND (按位与)
- `ALUControl = 11`: OR (按位或)

**标志位生成**:
1. **N (Negative)**: `ALUFlags[3] = ALUResult[31]`
   - 结果的最高位,表示符号
2. **Z (Zero)**: `ALUFlags[2] = (ALUResult == 0)`
   - 结果是否为零
3. **C (Carry)**: `ALUFlags[1] = Cout && (~ALUControl[1])`
   - 仅在加减法时有效,表示进位/借位
4. **V (Overflow)**: `ALUFlags[0] = ...`
   - 仅在加减法时有效,表示有符号溢出
   - 当两个同号数相加得到异号结果时发生

**实现细节**:
- 减法通过补码实现: A - B = A + (~B) + 1
- 标志位仅在数据处理指令且S位置1时更新

---

### 10. Shifter (桶形移位器)

**功能**: 对数据进行移位/旋转操作

**支持的操作**:
- `Sh = 00`: **LSL** (逻辑左移)
  - 低位补0
- `Sh = 01`: **LSR** (逻辑右移)
  - 高位补0
- `Sh = 10`: **ASR** (算术右移)
  - 高位补符号位
- `Sh = 11`: **ROR** (循环右移)
  - 移出的位从另一端补回

**移位量**: `Shamt5[4:0]` (0-31位)

**实现方法**:
- 5级桶形移位器
- 每级根据Shamt5的相应位决定是否移位:
  - Shamt5[4]: 移16位
  - Shamt5[3]: 移8位
  - Shamt5[2]: 移4位
  - Shamt5[1]: 移2位
  - Shamt5[0]: 移1位

**示例**:
- 左移5位: Shamt5 = 00101
  - 第2级: 移4位
  - 第0级: 移1位
  - 总共: 4 + 1 = 5位

---

### 11. Extend (立即数扩展单元)

**功能**: 将指令中的立即数扩展为32位

**扩展模式**:
1. **ImmSrc = 00**: 数据处理立即数
   - 零扩展8位: `{24'b0, InstrImm[7:0]}`
2. **ImmSrc = 01**: 加载/存储立即数
   - 零扩展12位: `{20'b0, InstrImm[11:0]}`
3. **ImmSrc = 10**: 分支立即数
   - 符号扩展24位并左移2位: `{{6{InstrImm[23]}}, InstrImm[23:0], 2'b00}`
   - 左移2位是因为指令地址必须字对齐

---

## 数据流转详解

### 典型指令执行流程

#### 示例1: ADD R0, R1, R2 (寄存器加法)

**指令编码**: `E0810002` (假设条件为AL)

**数据流**:
```
1. 取指阶段:
   PC → INSTR_MEM → Instr = E0810002

2. 译码阶段:
   Instr[31:28] = E (AL, 总是执行)
   Instr[27:26] = 00 (数据处理)
   Instr[25] = 0 (寄存器型)
   Instr[24:21] = 0100 (ADD)
   Instr[19:16] = 0001 (R1)
   Instr[15:12] = 0000 (R0)
   Instr[3:0] = 0010 (R2)

   Decoder输出:
   - RegSrc = 00 (A1=Rn, A2=Rm)
   - ALUSrc = 0 (使用移位后的寄存器)
   - ALUControl = 00 (ADD)
   - RegWrite = 1
   - MemWrite = 0

3. 执行阶段:
   RegisterFile读取:
   - A1 = R1 → RD1 = RegBank[1]
   - A2 = R2 → RD2 = RegBank[2]

   Shifter处理:
   - ShIn = RD2
   - Sh = 00, Shamt5 = 00000 (无移位)
   - ShOut = RD2

   ALU计算:
   - Src_A = RD1
   - Src_B = ShOut
   - ALUResult = Src_A + Src_B
   - ALUFlags = {N, Z, C, V}

4. 写回阶段:
   RegisterFile写入:
   - A3 = R0
   - WD3 = ALUResult (因MemtoReg=0)
   - WE3 = RegWrite = 1
   - RegBank[0] ← ALUResult

5. PC更新:
   - PCSrc = 0 (非分支)
   - PC ← PC + 4
```

#### 示例2: LDR R3, [R4, #8] (加载指令)

**指令编码**: `E5943008`

**数据流**:
```
1. 取指阶段:
   PC → INSTR_MEM → Instr = E5943008

2. 译码阶段:
   Instr[27:26] = 01 (存储器访问)
   Instr[25] = 1 (立即数偏移)
   Instr[23] = 1 (U=1, 正偏移)
   Instr[20] = 1 (L=1, 加载)
   Instr[19:16] = 0100 (R4, 基址寄存器)
   Instr[15:12] = 0011 (R3, 目标寄存器)
   Instr[11:0] = 008 (偏移量)

   Decoder输出:
   - RegSrc = 00 (A1=Rn)
   - ALUSrc = 1 (使用立即数)
   - ImmSrc = 01 (12位立即数)
   - ALUControl = 10 (ADD)
   - MemtoReg = 1 (使用存储器数据)
   - RegWrite = 1
   - MemWrite = 0

3. 执行阶段:
   RegisterFile读取:
   - A1 = R4 → RD1 = RegBank[4]

   Extend扩展:
   - InstrImm[11:0] = 008
   - ExtImm = {20'b0, 12'h008} = 32'h00000008

   ALU计算地址:
   - Src_A = RD1 (R4的值)
   - Src_B = ExtImm (8)
   - ALUResult = Src_A + 8

4. 访存阶段:
   地址译码:
   - ALUResult → 判断存储器区域
   - ReadData ← MEM[ALUResult]

5. 写回阶段:
   RegisterFile写入:
   - A3 = R3
   - WD3 = ReadData (因MemtoReg=1)
   - WE3 = RegWrite = 1
   - RegBank[3] ← ReadData

6. PC更新:
   - PC ← PC + 4
```

#### 示例3: BEQ LABEL (条件分支)

**指令编码**: `0AFFFFFC` (假设向后跳转16字节)

**数据流**:
```
1. 取指阶段:
   PC → INSTR_MEM → Instr = 0AFFFFFC

2. 译码阶段:
   Instr[31:28] = 0 (EQ条件, Z=1时执行)
   Instr[27:26] = 10 (分支)
   Instr[23:0] = FFFFFC (有符号偏移)

   Decoder输出:
   - Branch = 1
   - PCS = 1
   - RegSrc = 01 (A1=R15)
   - ALUSrc = 1 (使用立即数)
   - ImmSrc = 10 (24位分支立即数)
   - ALUControl = 10 (ADD)
   - RegWrite = 0

3. 条件判断:
   CondLogic检查:
   - Cond = 0 (EQ)
   - 条件: Z = 1?
   - 假设Z = 1 (上次比较结果相等)
   - CondEx = 1 (条件满足)
   - PCSrc = PCS && CondEx = 1

4. 执行阶段:
   RegisterFile读取:
   - A1 = R15 → RD1 = PC + 8

   Extend扩展:
   - InstrImm[23:0] = FFFFFC
   - ExtImm = {{6{1}}, 24'hFFFFFC, 2'b00}
   - = 32'hFFFFFFF0 (补码表示-16)

   ALU计算目标地址:
   - Src_A = PC + 8
   - Src_B = ExtImm = -16
   - ALUResult = PC + 8 - 16 = PC - 8

5. PC更新:
   - PCSrc = 1 (条件满足)
   - PC ← ALUResult = PC - 8
   - (实际效果: 跳回2条指令)
```

---

## 时序分析

### 单周期执行时序

```
时钟周期:    |<------- 1个周期 ------->|
             ___     ___     ___     ___
CLK:     ___|   |___|   |___|   |___|   |___

PC:      ----<  0  >-----<  4  >-----<  8  >----

阶段:    |取指|译码|执行|访存|写回|
         |    (全部在组合逻辑中完成)   |
                                   ↑
                              时钟上升沿:
                              - PC更新
                              - 寄存器写入
                              - 存储器写入
                              - 标志位更新
```

**关键时序路径**:
1. **最长路径** (决定最高时钟频率):
   ```
   PC → 指令存储器 → Decoder → CondLogic →
   RegisterFile → Shifter → ALU →
   数据存储器 → RegisterFile写入
   ```

2. **分支路径**:
   ```
   PC → 指令存储器 → Decoder → CondLogic →
   RegisterFile → Extend → ALU → PC更新
   ```

---

## 存储器系统

### 存储器布局

```
地址范围              | 类型           | 大小    | 读写
---------------------|----------------|---------|--------
0x00000000-0x000001FC| 指令存储器     | 512字节 | 只读
0x00000200-0x000003FC| 常量数据存储器 | 512字节 | 只读
0x00000800-0x000009FC| 变量数据存储器 | 512字节 | 读写
```

### 地址计算

**指令地址**:
- PC值为字节地址,但必须4字节对齐
- 存储器索引使用PC[8:2],因为:
  - PC[1:0]总是00(字对齐)
  - PC[8:2]提供7位索引(0-127)

**数据地址**:
- ALUResult为字节地址
- 存储器索引使用ALUResult[8:2]

---

## I/O接口

### LED显示
- 16位LED显示当前PC值
- 每个LED对应PC的一位
- 复位时LED清零

### 七段数码管显示
- 8位数码管显示32位十六进制数
- 通过DIP开关选择要查看的存储器地址
- 1kHz刷新率避免闪烁
- 显示变量数据存储器内容

### DIP开关
- 7位开关提供0-127的地址选择
- 选择变量数据存储器的地址
- 所选地址的内容显示在七段数码管上

### 按钮
- **RESET**: 复位整个系统
  - PC ← 0
  - 寄存器清零
  - 标志位清零
  - LED和数码管清零
- **PAUSE**: 暂停时钟
  - 暂停时,时钟分频器停止计数
  - CPU状态保持不变

---

## 性能特性

### 时钟频率
- **FPGA基准时钟**: 100MHz
- **CPU时钟** (可配置):
  - CLK_DIV_BITS = 0: 100MHz (最大性能)
  - CLK_DIV_BITS = 25: ~3Hz (调试模式)
  - CLK_DIV_BITS = 26: ~1.5Hz (单步模式)

### 指令吞吐量
- **单周期CPU**: 每时钟周期执行1条指令
- **IPC** (Instructions Per Cycle): 1.0
- **示例**: 3Hz时钟 → 3 MIPS

### 关键路径延迟
估计的组合逻辑延迟:
1. 指令存储器读取: ~2ns
2. 指令译码: ~1ns
3. 寄存器读取: ~1ns
4. 移位器: ~3ns
5. ALU: ~5ns
6. 数据存储器读取: ~2ns
7. 建立时间: ~1ns

**总延迟**: ~15ns → 理论最高频率约66MHz

---

## 设计特点与优化

### 1. 单周期设计
**优点**:
- 简单,易于理解和调试
- 指令执行可预测
- 无需流水线冲突处理

**缺点**:
- 时钟周期受最长指令限制
- 简单指令浪费时钟周期
- 功耗较高

### 2. 条件执行
- ARM特色:所有指令都可条件执行
- 减少分支指令数量
- 提高代码密度

### 3. 桶形移位器
- 与ALU并行工作
- 单周期内完成任意位数移位
- 增强数据处理能力

### 4. 哈佛架构
- 指令和数据存储器分离
- 可同时访问指令和数据
- 简化单周期设计

---

## 调试与验证

### 调试接口
1. **LED显示**: 实时显示PC值
2. **七段数码管**: 查看任意存储器内容
3. **PAUSE按钮**: 暂停执行以观察状态

### 验证方法
1. **仿真测试**: 使用Wrapper模块进行功能仿真
2. **综合测试**: 使用TOP模块在FPGA上综合
3. **硬件测试**: 在Nexys4开发板上运行

### 常见问题排查
1. **PC不递增**: 检查时钟信号和PAUSE按钮
2. **指令不执行**: 检查条件码和标志位
3. **存储器读写错误**: 检查地址范围和MemWrite信号
4. **数码管显示错误**: 检查DIP开关设置

---

## 总结

本ARM CPU设计实现了一个完整的单周期处理器,包含:
- ✅ 数据处理指令 (ADD, SUB, AND, OR, CMP, CMN)
- ✅ 存储器访问指令 (LDR, STR)
- ✅ 分支指令 (B + 条件码)
- ✅ 条件执行机制
- ✅ 移位操作
- ✅ 完整的I/O接口

该设计适合教学和原型验证,展示了ARM处理器的核心特性和单周期CPU的设计方法。

---

## 附录: 信号速查表

### 控制信号

| 信号 | 位宽 | 来源 | 目的 | 说明 |
|------|------|------|------|------|
| PCSrc | 1 | CondLogic | PC | PC来源选择 |
| MemtoReg | 1 | Decoder | ARM | 寄存器写数据选择 |
| MemWrite | 1 | CondLogic | Wrapper | 存储器写使能 |
| ALUSrc | 1 | Decoder | ARM | ALU第二操作数选择 |
| RegWrite | 1 | CondLogic | RegFile | 寄存器写使能 |
| RegSrc | 2 | Decoder | ARM | 寄存器地址选择 |
| ImmSrc | 2 | Decoder | Extend | 立即数扩展类型 |
| ALUControl | 2 | Decoder | ALU | ALU操作选择 |
| FlagW | 2 | Decoder | CondLogic | 标志位写使能 |

### 数据信号

| 信号 | 位宽 | 来源 | 目的 | 说明 |
|------|------|------|------|------|
| PC | 32 | ProgramCounter | Wrapper | 程序计数器 |
| Instr | 32 | Wrapper | ARM | 当前指令 |
| ALUResult | 32 | ALU | Wrapper | ALU计算结果/存储器地址 |
| WriteData | 32 | ARM | Wrapper | 写入存储器的数据 |
| ReadData | 32 | Wrapper | ARM | 从存储器读取的数据 |
| ALUFlags | 4 | ALU | CondLogic | 标志位{N,Z,C,V} |

---

*文档生成时间: 2025年*
*版本: 1.0*
